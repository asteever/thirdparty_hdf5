#! /usr/local/bin/perl -w
require 5.003;
use Cwd;

# Builds a release.  Arguments are zero or more of the words.
#
#	tar		-- build a tar file			*.tar
#	compress	-- build a compressed tar file		*.tar.Z
#	gzip		-- build a compressed tar file		*.tar.gz
#	bzip2		-- build a compressed tar file		*.tar.bz2
#
# If no arguments are given then `gzip' is assumed.  If the only argument
# is the word `all' then all forms are used.

$releases = "./releases";	# Directory for release tarballs

##############################################################################
# Read version info, return an array (MAJOR,MINOR,RELEASE) or
# a string "MAJOR.MINOR.RELEASE"
#
sub getver () {
   my @ver;
   open SRC, "./src/H5public.h" or die "cannot read HDF5 version";
   while (<SRC>) {
      $ver[0] = $1 if /define\s+H5_VERS_MAJOR\s+(\d+)/;
      $ver[1] = $1 if /define\s+H5_VERS_MINOR\s+(\d+)/;
      $ver[2] = $1 if /define\s+H5_VERS_RELEASE\s+(\d+)/;
   }
   close SRC;
   wantarray ? @ver : "$ver[0].$ver[1].$ver[2]";
}

##############################################################################
# Set version information.  Input is a string or an array.
#
sub setver ($;$$) {
   my @ver = @_;
   local $_;

   if ($ver[0]=~/\D/) {
      @ver = $ver[0] =~ /^(\d+)\.(\d+)\.(\d+)$/ or return "";
   }

   $_ = `cat ./src/H5public.h`;
   s/(define\s+H5_VERS_MAJOR\s+)(\d+)/$1$ver[0]/;
   s/(define\s+H5_VERS_MINOR\s+)(\d+)/$1$ver[1]/;
   s/(define\s+H5_VERS_RELEASE\s+)(\d+)/$1$ver[2]/;
   open SRC, "> ./src/H5public.h" or return "";
   print SRC $_;
   close SRC;

   return 1;
}

##############################################################################
# Make sure MANIFEST contains all the necessary files.  If we are running
# under CVS then look at the CVS/Entries files to get the names that should
# be in the manifest.  Otherwise we really can't do anything.
#
sub manifest () {
    my ($fname, %manifest);
    my $nprobs=0;

    # We can't do anything if we're not running under cvs.
    return "" unless -d "CVS";

    # Read the files from the manifest.
    open MANIFEST, "MANIFEST" or die "unable to read manifest";
    while (<MANIFEST>) {
	chomp;
	$manifest{$_} = 1;
    }
    close MANIFEST;

    # Read files from CVS/Entries
    open FIND, "find . -name Entries -print | sort |" or
	die "unable to find CVS entries";
    while (defined($fname=<FIND>)) {
	chomp $fname;
	my ($dir) = $fname =~ m%(.*)/CVS/Entries%;
	open ENTRIES, $fname or die "unable to open $fname";
	while (<ENTRIES>) {
	    my ($ename);
	    next unless ($ename) = m%^/([^/]+)/[^-]%;
	    $ename = "$dir/" . $ename;
	    if (exists $manifest{$ename}) {
		delete $manifest{$ename};
	    } else {
		print "NEW: $ename\n";
		$nprobs++;
	    }
	}
	close ENTRIES;
    }
    close FIND;

    for (sort keys %manifest) {
	print "OLD: $_\n";
	$nprobs++;
    }

    if ($nprobs) {
	print "Please add the new files to MANIFEST and remove the old\n";
	print "files and try again.  The MANIFEST should contain all files\n";
	print "that are to be distributed for a release.\n";
	exit 1;
    }
}


##############################################################################
# Build a release
#
sub release (@) {
   my @types = @_;
   my ($ver, $status, $created_symlink);
   my ($batch) = 0;
   local $_;

   if (@types>0 && $types[0] =~ /^-?-batch$/) {
     $batch = 1;
     shift @types;
   }

   # Make sure no one forgot to update MANIFEST
   manifest;

   # Make sure the version number is correct.
   $ver = getver;
   if ($batch) {
     print "Releasing version $ver\n";
   } else {
     print "HDF version to release [$ver] ";
     return "" unless defined ($_=<STDIN>);
     chomp;
     (setver ($ver=$_) or die "cannot set version") if /\S/;
   }

   # Update the README file to contain the new version and date
   # information.
   my $today = sprintf "19%02d-%02d-%02d %02d:%02d UTC", (gmtime)[5,4,3,2,1];
   $_ = `cat README`;
   s[^(This is hdf5-)\d+.\d+.\d+( released on )(\d+-?){3} \d+:\d+ UTC]
    [$1$ver$2$today]s;
   system ("cp -p README README~");
   open README, ">README" or die "unable to open README: $!\n";
   print README;
   close README;
   
   # Move default top-level makefile into place.
   $status = system "cp Makefile.dist Makefile";
   die "cannot install default Makefile" if $status >> 8;

   # Make sure release directory exists
   (mkdir $releases, 0777 or die "cannot create $releases")
       unless -d $releases;
   die "no manifest" unless -r "MANIFEST";

   # We build the release from above the root of the source tree so the
   # hdf5 directory appears as part of the name in the tar file. We create
   # a temporary symlink called something like `hdf5-1.0.0a' that points to
   # our current working directory.
   $_ = cwd;
   my ($parent,$root) = m%(.*)/(.*)$% or die "cannot split directory";
   if ($root ne "hdf5-$ver" && ! -e "../hdf5-$ver") {
      symlink $root, "../hdf5-$ver" or die "cannot create link";
      $created_symlink = 1;
   }
   my $name = "$root/$releases/hdf5-$ver";

   # Build the releases.
   @types = ("gzip") unless @types;
   @types = qw/tar gzip compress bzip2/ if 1==@types && "all" eq $types[0];
   $_ = `cat MANIFEST`;
   s/^\.\///mg;
   @filelist = ("Makefile", split /\s*\n/, $_);
   $filelist = join " ", map {"hdf5-$ver/$_"} @filelist;

   chdir ".." or die;
   for (@types) {
      print "Compressing with $_...\n";

      /^tar$/ && do {
	 $status = system "tar cf $name.tar $filelist";
	 next;
      };

      /^gzip$/ && do {
	 $status = system "tar cf - $filelist |gzip -9 >$name.tar.gz";
	 next;
      };

      /^compress$/ && do {
	 $status = system "tar cf - $filelist |compress -c >$name.tar.Z";
	 next;
      };

      /^bzip2$/ && do {
	 $status = system "tar cf - $filelist |bzip2 -9 >$name.tar.bz2";
	 next;
      };
   } continue {
      print STDERR "$_ failed\n" if $status >> 8;
   }
   chdir $root or die;

   # Remove the temporary symlink we created above.
   unlink "../hdf5-$ver" if $created_symlink;
   

   # Update version info
   if ($batch) {
     my ($v1,$v2,$v3) = $ver =~ /^(\d+)\.(\d+)\.(\d+)$/;
     $v3 += 1;
     setver ($ver = "$v1.$v2.$v3") or die "cannot set version";
     print "Development version set to $ver\n";
   } else {
     print <<EOF;

If this is a real release then the version number for continued development
should be incremented.  Otherwise just press return.

EOF
     print "Set development version to [", ($ver=getver), "] ";
     return "" unless defined ($_ = <STDIN>);
     chomp;
     (setver ($ver=$_) or die "cannot set version") if /\S/;

     if (-d "CVS") {
       my $tag = $ver;
       $tag =~ s/\./-/g;
       print "Tag CVS sources with \"$tag\"? [n] ";
       chomp ($_ = <STDIN>);
       if ($_ eq 'y') {
	 print "Tagging CVS sources...\n";
	 my $status = system "cvs tag -R $tag";
	 die "cvs tag failed" if $status >> 8;
       }
     }
   }

   return 1;
}

release @ARGV;
