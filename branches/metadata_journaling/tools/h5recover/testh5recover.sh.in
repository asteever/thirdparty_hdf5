#! /bin/sh
#
# Copyright by The HDF Group.
# All rights reserved.
#
# This file is part of HDF5.  The full HDF5 copyright notice, including
# terms governing use, modification, and redistribution, is contained in
# the files COPYING and Copyright.html.  COPYING can be found at the root
# of the source code distribution tree; Copyright.html can be found at the
# root level of an installed copy of the electronic HDF5 document set and
# is linked from the top-level documents page.  It can also be found at
# http://hdfgroup.org/HDF5/doc/Copyright.html.  If you do not have
# access to either file, you may request a copy from help@hdfgroup.org.
#
# Tests for the h5recover tool

# Determine which filters are available
USE_FILTER_SZIP="@USE_FILTER_SZIP@"
USE_FILTER_DEFLATE="@USE_FILTER_DEFLATE@"
USE_FILTER_SHUFFLE="@USE_FILTER_SHUFFLE@"
USE_FILTER_FLETCHER32="@USE_FILTER_FLETCHER32@"
USE_FILTER_NBIT="@USE_FILTER_NBIT@"
USE_FILTER_SCALEOFFSET="@USE_FILTER_SCALEOFFSET@"

TOOL=trecover                  # The tool name
TOOL_BIN=`pwd`/$TOOL           # The path of the tool binary
TOOLDataFile=trecover.h5
TOOLJournalFile=$TOOLDataFile.jnl
TOOLCTLDataFile=CTL$TOOLDataFile
RECOVERTOOL=h5recover                      # The tool name
RECOVERTOOL_BIN=`pwd`/$RECOVERTOOL         # The path of the tool binary
#RECOVERTOOL_BIN="cp $TOOLCTLDataFile"
# Use my own h5diff since h5diff has errors such as returning 0 when comparing
# an empty file with a non-empty one.
#H5DIFF=../h5diff/h5diff
H5DIFF=MYH5DIFF
H5DUMP=../h5dump/h5dump
TESTDIR=`pwd`/../testfiles


CMP='cmp -s'
DIFF='diff'

nerrors=0
verbose=yes

# The build (current) directory might be different than the source directory.
if test -z "$srcdir"; then
   srcdir=.
fi

#test -d $TESTDIR || mkdir $TESTDIR

# Print a line-line message left justified in a field of 70 characters
# beginning with the word "Testing".
#
TESTING() {
   SPACES="                                                               "
   echo "Testing $* $SPACES" | cut -c1-70 | tr -d '\012'
}

# Run a test and print PASS or *FAIL*.  If a test fails then increment
# the `nerrors' global variable and (if $verbose is set) display the
# difference between the actual output and the expected output. The
# expected output is given as the first argument to this function and
# the actual output file is calculated by replacing the `.ddl' with
# `.out'.  The actual output is not removed if $HDF5_NOCLEANUP has a
# non-zero value.

# $1: Expected output file
# $2-: arguments for the trecover program
#
TOOLTEST() {
    expect="$srcdir/testfiles/$1"
    actual=`basename $1 .txt`.out
    actual_err=`basename $1 .txt`.err
    shift

    # Run test.
    TESTING $TOOL $@
    # Generate the data, journal and the control files.
    # The testing shell will still print "Terminated" though the signal is
    # trapped. Need to find a way to block or filter it out.
    trap true 15
    $RUNSERIAL $TOOL_BIN $@
    # expect first diff to fail
    # $RUNSERIAL $H5DIFF $TOOLDataFile $TOOLCTLDataFile > /dev/null 2>&1
    try_diff $TOOLDataFile $TOOLCTLDataFile try_diff.stdout try_diff.stderr
    if [ $? = 0 ]; then
	echo first diff did not fail as expected
    fi
    # Recover the file.
    # $RUNSERIAL $RECOVERTOOL_BIN -j $TOOLJournalFile $TOOLDataFile > /dev/null
    try_h5recover $TOOLJournalFile $TOOLDataFile
    if [ $? != 0 ]; then
	echo $RECOVERTOOL failed
	nerrors="`expr $nerrors + 1`"
    fi
    # JRM -- 12/10/08
    # Replaced the second diff with a call to try_verify.  While you
    # should see the source code in trecover_verifier.c for details,
    # in essence this test checks to see that the metadata is as it
    # should be, and that the raw data is "reasonable".

    try_verify

    if [ $? = 0 ]; then
        echo " PASSED"
    else
        echo "*FAILED*"
        nerrors="`expr $nerrors + 1`"
    fi

#    # second diff should produce expected output
#    (
#	echo "#############################"
#	echo "Expected output for '$TOOL $@'" 
#	echo "#############################"
#	$RUNSERIAL $H5DIFF $TOOLDataFile $TOOLCTLDataFile
#    ) >$actual 2>$actual_err
#    cat try_diff.stdout >> $actual
#    cat try_diff.stderr >> $actual_err
#    cat $actual_err >> $actual
#
#    if [ ! -f $expect ]; then
#	echo "missing expected output file($expect)"
#	nerrors="`expr $nerrors + 1`"
#    elif $CMP $expect $actual; then
#	echo " PASSED"
#    else
#	echo "*FAILED*"
#	echo "    Expected result (*.ddl) differs from actual result (*.out)"
#	nerrors="`expr $nerrors + 1`"
#	test yes = "$verbose" && $DIFF $expect $actual |sed 's/^/    /'
#    fi

    # Clean up output file
    if test -z "$HDF5_NOCLEANUP"; then
	 rm -f $actual $actual_err
	 rm -f try_diff.stderr try_diff.stdout
	 rm -f try_h5recover.stderr try_h5recover.stdout
         rm -f try_verify.stdout try_verify.stderr
    fi
}


# Print a "SKIP" message
SKIP() {
	 TESTING $TOOL $@
	  echo  " -SKIP-"
}


# My own h5diff because h5diff has errors such as returning 0 when comparing
# an empty file with a non-empty one.
# Compare the h5dump output of two files, return 0 if the same, else 1.
# The cp to x.data is needed to make h5dump output showing the same filename.
MYH5DIFF(){
    xout1=x1.out
    xerr1=x1.err
    xout2=x2.out
    xerr2=x2.err
    xdata=x.h5
    cp $1 $xdata
    $RUNSERIAL $H5DUMP $xdata > $xout1 2> $xerr1
    cat $xerr1 >> $xout1
    cp $2 $xdata
    $RUNSERIAL $H5DUMP $xdata > $xout2 2> $xerr2
    cat $xerr2 >> $xout2
#    $DIFF $xout1 $xout2
    try_diff $xout1 $xout2 try_diff.stdout try_diff.stderr
    if [ $? = 0 ]; then
	return 0
    else
	return 1
    fi
}


##############################################################################
##                                                                          ##
## The following functions are used to perform a sort of "temporal scan"    ##
## of the possible HDF5 file and journal file value created by trecover.    ##
##                                                                          ##
## The basic idea is to do run trecover -a n over a wide selection of       ##
## values for n in the hope that if there is a window in which the journal  ##
## is not maintained properly, we will find it when we force a crash, and   ##
## then attempt to recover.                                                 ##
##                                                                          ##
## The following pseudo code describes the test:                            ##
##                                                                          ##
## let n = 0.01;       // these values are arbitrary                        ##
## let incr = 0.001;   // for now                                           ##
## let fail = false;                                                        ##
##                                                                          ##
## do {                                                                     ##
##     trecover -a n                                                        ##
##                                                                          ##
##     if ( trecover.h5.jnl exists )                                        ##
##     {                                                                    ##
##         if ( h5dump trecover.h5 is able to open trecover.h5 )            ##
##         {                                                                ##
##                                                                          ##
##             fail = true;                                                 ##
##                                                                          ##
##         } else if ( h5recover -j trecover.h5.jnl trecover.h5 fails ) {   ##
##                                                                          ##
##             fail = true;                                                 ##
##                                                                          ##
##         } else if ( h5dump trecover.h5 can't open trecover.h5 ) {        ##
##                                                                          ##
##             fail = true;                                                 ##
##         }                                                                ##
##     } else if ( h5dump trecover.h5 can't open trecover.h5 ) {            ##
##                                                                          ##
##         fail = true;                                                     ##
##     }                                                                    ##
##                                                                          ##
##     n += incr;                                                           ##
##                                                                          ##
## } while ( ( trecover.h5.jnl exists ) && ( not fail ) )                   ##
##                                                                          ##
##############################################################################

# On some target systems, the return code of a program is inaccessible.
# Get around this by storing stdout and stderr to separate files, and 
# inferring that the files are different if either file is non-empty
try_diff() {

    return_code=0

    TRY_DIFF_INPUT1=$1
    TRY_DIFF_INPUT2=$2
    TRY_DIFF_STDOUT=$3
    TRY_DIFF_STDERR=$4
    
    rm -f $TRY_DIFF_STDOUT $TRY_DIFF_STDERR

    ($DIFF $TRY_DIFF_INPUT1 $TRY_DIFF_INPUT2 > $TRY_DIFF_STDOUT) \
    			2> $TRY_DIFF_STDERR
    # check both return code and contents of stdout and stderr files -- 
    # report files different if either the return code isn't 0, or 
    # either of the output files is non-empty.
    if [ $? != 0 ]
    then

	# echo "$DIFF returned non-zero return code."
    	return_code=1

    else 
    
    	if [ `wc -c < ${TRY_DIFF_STDOUT}` != '0' ]
        then

	    # echo "#DIFF returned non-empty stdout file."
            return_code=1

	else

	    if [ `wc -c < ${TRY_DIFF_STDERR}` != '0' ]
	    then

	        # echo "$DIFF returned non-empty stderr file."
                return_code=1

	    fi
        fi
    fi

    return $return_code
}


# On some target systems, the return code of a program is inaccessible.
# Get around this by storing stdout and stderr to separate files, and 
# inferring that the return code is 0 if the stderr file is empty.

try_h5dump() {

    return_code=0

    TRY_H5DUMP_INPUT=$1
    TRY_H5DUMP_STDOUT=$2
    TRY_H5DUMP_STDERR=$3
    
    rm -f $TRY_H5DUMP_STDOUT $TRY_H5DUMP_STDERR

    # echo "(h5dump $TRY_H5DUMP_INPUT > $TRY_H5DUMP_STDOUT) \
    #			2> $TRY_H5DUMP_STDERR"

    ( $RUNSERIAL ../h5dump/h5dump $TRY_H5DUMP_INPUT > $TRY_H5DUMP_STDOUT ) \
			2> $TRY_H5DUMP_STDERR

    # check both return code and contents of stderr file -- report 
    # failure if either the return code is non-zero or the stderr
    # file is non-empty.
    if [ $? != 0 ]
    then

	# echo "try_h5dump failed by return code."
    	return_code=1

    else 
    
    	if [ `wc -c < $TRY_H5DUMP_STDERR` != '0' ]
        then

	    # echo "try_h5dump failed by stderr file."
            return_code=1

        fi
    fi

    return $return_code
}

try_h5recover() {

    return_code=0
    TRY_RECOVER_JNL_FILE=$1
    TRY_RECOVER_H5_FILE=$2

    rm -f try_h5recover.stdout try_h5recover.stderr

    ( $RUNSERIAL ./h5recover -j $TRY_RECOVER_JNL_FILE $TRY_RECOVER_H5_FILE > \
		try_h5recover.stdout ) 2> try_h5recover.stderr

    if [ `wc -c < try_h5recover.stderr` != '0' ]
    then

        return_code=1

    fi

    return $return_code
}

try_verify() {

    return_code=0

    rm -f try_verify.stdout try_verify.stderr

    ( $RUNSERIAL ./trecover -v > try_verify.stdout) 2> try_verify.stderr


    # check both return code and contents of stderr file -- report 
    # failure and cat the stderr file if either the return code is 
    # non-zero or the stderr file is non-empty.
    if [ $? != 0 ]
    then

	# echo "try_verify reports failure by return code."
    	return_code=1
        cat try_verify.stderr

    else

        if [ `wc -c < try_verify.stderr` != '0' ]
        then

	    # echo "try_verify reports failure by stderr file."
            return_code=1
            cat try_verify.stderr

        fi
    fi

    # cat the stdout file if it is non empty
    if [ `wc -c < try_h5recover.stdout` != '0' ]
    then

        cat try_verify.stdout

    fi

    return $return_code
}


test_point() {

    pass=1
    seconds=$1
    usecs=$2

    if [ $usecs -lt 10 ] 
    then

    	delay=${seconds}.00000${usecs}

    else
    
    	if [ $usecs -lt 100 ] 
	then

            delay=${seconds}.0000${usecs}

        else

            if [ $usecs -lt 1000 ]
            then

                delay=${seconds}.000${usecs}

            else

                if [ $usecs -lt 10000 ]
                then

                    delay=${seconds}.00${usecs}

                else

                    if [ $usecs -lt 100000 ]
                    then

                        delay=${seconds}.0${usecs}

                    else

                        delay=${seconds}.${usecs}

                    fi
                fi
            fi
        fi
    fi

    echo "trecover -a $delay"

    # Generate the data, journal and the control files.
    # The testing shell will still print "Terminated" though the signal is
    # trapped. Need to find a way to block or filter it out.
    trap true 15
    $RUNSERIAL ./trecover -a $delay > /dev/null 2>&1

    if [ -f trecover.h5 ]
    then

    	# echo "trecover.h5 exists"

        try_h5dump trecover.h5 try_h5dump.stdout try_h5dump.stderr

	if [ $? -ne 0 ]
	then

	    # echo "h5dump trecover.h5 failed (1)"

	    if [ -f trecover.h5.jnl ]
	    then

	    	# echo "trecover.h5.jnl exists -- try to recover"

		# echo "./h5recover -j trecover.h5.jnl trecover.h5"

		try_h5recover trecover.h5.jnl trecover.h5

		if [ $? -ne 0 ]
		then

		    # echo "h5recover failed!!! FAILED"
		    pass=0

		else

		    # echo "h5recover succeeded -- try h5dump again"

                    try_h5dump trecover.h5 try_h5dump.stdout try_h5dump.stderr

	            if [ $? -ne 0 ]
	            then

	                # echo "h5dump trecover.h5 failed again?!? FAILED"
			pass=0

                    else

		        # echo "h5dump trecover.h5 succeeded (2)"

                        # since h5dump works, try to verify the recovery
                        try_verify

                        if [ $? -ne 0 ]
                        then

                            # echo "try_verify failed!!! FAILED"
                            pass=0

                        else

                            # echo "try_verify succeeded -- PASS"
			    pass=1

                        fi
		    fi

		fi

	    else

	    	# echo "trecover.h5.jnl doesn't exist!!! FAILED"
		pass=0

	    fi

	else

	    # echo "h5dump trecover.h5 succeeded on first attempt"

	    if [ -f trecover.h5.jnl ]
            then

	        # echo "h5dump trecover.h5 succeeded on first attempt"
                # echo "journal file exists."
                ls -l trecover.h5.jnl

            # else

	        # echo "h5dump trecover.h5 succeeded on first attempt"
                # echo "no journal file exists."

            fi

	    pass=1

        fi
    fi

    return $pass
}

run_jnl_invarient_test() {

    echo "Starting journaling invarients test:"
    echo ""
    echo "This test runs the same journaled test application repeatedly, "
    echo "but with a gradually increasing delay before the test procees is"
    echo "killed.  The opjective is to search for windows in which the "
    echo "the journaling invarients are not maintained.  If the test finds "
    echo "such a case, the file should be unreadable after the journal is "
    echo "recovered."
    echo ""
    echo "This test generates a lot of garbage output, as we are killing the "
    echo "test application repeatedly.  Ignore this output, and only look at"
    echo "the last line."
    echo ""
    echo "Starting the test now:"
    echo ""
    echo "Testing journaling invarients...."
    echo ""

    finished=0;
    sec=0;
    usec=0;

    while [ $finished -eq 0 ] 
    do
	usec="`expr $usec + 50`"

	if [ $usec -ge 1000000 ]
	then

	    usec=0;
	    sec="`expr $sec + 1`"

	fi

	test_point $sec $usec

	pass=$?

	echo "pass = $pass"

	if [ $pass -eq 0 ]
	then

	    finished=1

	fi

	if [ ! -f trecover.h5.jnl ]
	then

	    finished=1

	fi

    done

    echo -n "Testing journaling invarients"
    echo -n "                                          "

    if [ $pass -eq 0 ]
    then

        echo "FAILED"
	nerrors="`expr $nerrors + 1`"

    else

        echo "PASSED"

    fi

    # Clean up output files
    if test -z "$HDF5_NOCLEANUP"; then
	 rm -f try_h5dump.stderr try_h5dump.stdout
	 rm -f try_h5recover.stderr try_h5recover.stdout
         rm -f try_verify.stderr try_verify.stdout
    fi

    return

}


##############################################################################
###			  T H E   T E S T S                                ###
##############################################################################

# default test setting
TOOLTEST default.txt

# async crash
# Since the async crash is highly dependent on machine speeds, system load,
# the results may not always match.  One would need to compare the results
# against the expected results by hand.
#
# JRM -- 12/10/08
# this test is now subsumed in the invarient test.  Delete code for 
# this test eventually.
# TOOLTEST async_crash.txt -a 0.05

# Invarient test
# This is a very different test from the previous TOOLTEST calls -- 
# basic idea is to scan the execution time of a journaled process to 
# look for points in time at which the journaling invarients are not
# maintained.  see comments for details.
run_jnl_invarient_test

if test $nerrors -eq 0 ; then
   echo "All $TOOL tests passed."
fi

if test $nerrors -eq 0 ; then
    echo "All $TOOL tests passed."
    exit 0
else
    echo $nerrors errors encountered.
    exit 1
fi
